#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include "platform.h"
#define MINIAUDIO_IMPLEMENTATION
#include "miniaudio.h"
#include "renderer.h"

GLFWwindow* window;
ma_engine engine;
ma_sound homeMusic;

GLFWwindow* create_window();
void key_callback(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods);
void mouse_button_callback(GLFWwindow* window, i32 button, i32 action, i32 mods);
void framebuffer_size_callback(GLFWwindow* window, i32 width, i32 height);
void mouse_callback(GLFWwindow* window, f64 xpos, f64 ypos);
void load_textures();
void load_window_icon();

f32 lastFrame = 0.0f;
bool firstMouse = true;
f32 yaw = -90.0f;
f32 pitch = 0.0f;
f64 lastX = 400.0f;
f64 lastY = 300.0f;
f32 cameraSpeedMult = 20.0f;
f32 mouseSensitivity = 0.1f;

f32 deltaTime = 0;
i32 windowPosX = 0;
i32 windowPosY = 0;
bool isFullscreen = false;
mat4 projection;

i32 windowWidth = 1280;
i32 windowHeight = 720;

struct GameDLL {
    HMODULE dll;
    FILETIME lastWriteTime;
    game_init_fn game_init;
    game_update_and_render_fn game_update_and_render;
    game_update_input_fn game_update_input;
};

GameDLL game = {};

FILETIME get_last_write_time(const char* path) {
    WIN32_FILE_ATTRIBUTE_DATA data;
    GetFileAttributesExA(path, GetFileExInfoStandard, &data);
    return data.ftLastWriteTime;
}

void unload(GameDLL* g) {
    if (g->dll)
    {
        FreeLibrary(g->dll);
        g->dll = nullptr;
        g->game_init = nullptr;
        g->game_update_and_render = nullptr;
        g->game_update_input = nullptr;
    }
}

void load(GameDLL* g, const char* dllPath) {
    g->lastWriteTime = get_last_write_time(dllPath);

    CopyFileA(dllPath, "C:/Dev/opengl_code/InfiniteErl/x64/Debug/game_temp.dll", FALSE);

    g->dll = LoadLibraryA("game_temp.dll");
    g->game_init = (game_init_fn)GetProcAddress(g->dll, "game_init");
    g->game_update_and_render = (game_update_and_render_fn)GetProcAddress(g->dll, "game_update_and_render");
    g->game_update_input = (game_update_input_fn)GetProcAddress(g->dll, "game_update_input");
}

bool file_time_changed(FILETIME a, FILETIME b) {
    return (CompareFileTime(&a, &b) != 0);
}


boolean hotreload(GameDLL* g, const char* dllPath) {
    FILETIME newTime = get_last_write_time(dllPath);

    if (file_time_changed(newTime, g->lastWriteTime)) {
        char message_buffer[100];
        sprintf_s(message_buffer, 100, "HOT RELOAD\n");
        OutputDebugStringA(message_buffer);

        unload(g);
        Sleep(50);

        CopyFileA(
            dllPath,
            "C:/Dev/opengl_code/InfiniteErl/x64/Debug/game_temp.dll",
            FALSE
        );

        g->dll = LoadLibraryA("game_temp.dll");
        g->game_init =
            (game_init_fn)GetProcAddress(g->dll, "game_init");
        g->game_update_and_render =
            (game_update_and_render_fn)GetProcAddress(g->dll, "game_update_and_render");
        g->game_update_input =
            (game_update_input_fn)GetProcAddress(g->dll, "game_update_input");

        g->lastWriteTime = newTime;
        return true;
    }
    return false;
}

i32 APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, i32 cmdshow) {
    window = create_window();
    load_window_icon();
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    ma_engine_init(NULL, &engine);

    load_textures();
    load_fonts();
    load_shaders();

    load(&game, "C:/Dev/opengl_code/InfiniteErl/x64/Debug/Game.dll");
    RenderBuffer* buffer = allocate_render_buffer(2048 * 2048);
    if (!buffer) {
        OutputDebugStringA("Failed to allocate render buffer\n");
        return -1;
    }
    
    //maybe in the loop?
    GameMemory memory = {};
    memory.stateMemorySize = 64 * 1024 * 1024;
    memory.stateMemory = VirtualAlloc(0,
        memory.stateMemorySize,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE);

    if (!memory.stateMemory) {
        OutputDebugStringA("Failed to allocate game memory\n");
        return -1;
    }
    memset(memory.stateMemory, 0, memory.stateMemorySize);
    //
    memory.renderBuffer = buffer;
    memory.push_entity_fn = push_entity;
    memory.push_platform_fn = push_platform;
    memory.push_ui_text_fn = push_ui_text;
    memory.push_ui_image_fn = push_ui_image;
    memory.push_ui_page_fn = push_ui_page;
    
    memory.load_quad_buffer_fn = load_quad_buffer;
    memory.load_walls_buffer_fn = load_walls_buffer;
    memory.load_platform_buffer_fn = load_platform_buffers;

    game.game_init(&memory, 0);
    
    while (!glfwWindowShouldClose(window)) {
        if (hotreload(&game, "C:/Dev/opengl_code/InfiniteErl/x64/Debug/Game.dll")) {
            OutputDebugStringA("Hotreload succeeded\n");
            game.game_init(&memory, true);
        }
        f32 currentFrame = static_cast<float>(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;
        if (deltaTime > 0.1f) deltaTime = 0.1f;
        buffer->projection = projection;
        buffer->deltaTime = deltaTime;
        glfwPollEvents();
        if(game.game_update_and_render) game.game_update_and_render();
        render_buffer(buffer);
        glfwSwapBuffers(window);
    }
    
    //save();
    //cleanup();
    //game_close();
    glfwTerminate();
    return 0;
}

GLFWwindow* create_window() {
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(windowWidth, windowHeight, "ERL", NULL, NULL);
    if (window == NULL) {
        printf("Failed to create GLFW window\n");
        glfwTerminate();
    }
    glfwMakeContextCurrent(window);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        printf("Failed to initialize GLAD\n");
    }

    glViewport(0, 0, windowWidth, windowHeight);
    glEnable(GL_DEPTH_TEST);

    glfwSetKeyCallback(window, key_callback);
    //think about set joystick callback..
    glfwSetCursorPosCallback(window, mouse_callback);
    glfwSetMouseButtonCallback(window, mouse_button_callback);
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    f32 aspect = static_cast<f32>(windowWidth) / static_cast<f32>(windowHeight);
    projection = glm::perspective(glm::radians(FOV), aspect, 0.1f, Z_FAR);

    return window;
}

void toggle_fullscreen(GLFWwindow* window) {
    isFullscreen = !isFullscreen;

    i32 width, height, xpos, ypos, refresh;
    GLFWmonitor* monitor = nullptr;

    if (isFullscreen) {
        glfwGetWindowPos(window, &windowPosX, &windowPosY);
        glfwGetWindowSize(window, &windowWidth, &windowHeight);

        monitor = glfwGetPrimaryMonitor();
        const GLFWvidmode* mode = glfwGetVideoMode(monitor);
        width = mode->width;
        height = mode->height;
        xpos = 0;
        ypos = 0;
        refresh = 144;
    }
    else {
        width = windowWidth;
        height = windowHeight;
        xpos = windowPosX;
        ypos = windowPosY;
        refresh = 0;
    }

    glfwSetWindowMonitor(window, monitor, xpos, ypos, width, height, refresh);
    glfwMakeContextCurrent(window);
    glfwSwapInterval(1);

    glViewport(0, 0, width, height);
    f32 aspect = (height == 0) ? 1.0f : (f32)width / (f32)height;
    windowWidth = width;
    windowHeight = height;
    projection = glm::perspective(glm::radians(FOV), aspect, 0.1f, Z_FAR);
}

void load_window_icon() {
    i32 width, height, channels;
    unsigned char* pixels = stbi_load("./res/watt-ico.png", &width, &height, &channels, 0);
    if (!pixels) {
        printf("Unable to load window icon!\n");
    }

    GLFWimage icon_image;
    icon_image.width = width;
    icon_image.height = height;
    icon_image.pixels = pixels;

    glfwSetWindowIcon(window, 1, &icon_image);
    stbi_image_free(pixels);
}

void load_home_music() {
    if (ma_sound_init_from_file(&engine,
        "./audio/slow_space.wav",
        0, NULL, NULL, &homeMusic) == MA_SUCCESS)
    {
        ma_sound_set_looping(&homeMusic, MA_TRUE);
        ma_sound_start(&homeMusic);
    }
    else {
        printf("Failed to load home music\n");
    }
}

void unload_home_music() {
    ma_sound_uninit(&homeMusic);
}

void framebuffer_size_callback(GLFWwindow* window, i32 width, i32 height) {
    if (width == 0 || height == 0) return;
    windowWidth = width;
    windowHeight = height;
    glViewport(0, 0, width, height);

    f32 aspect = static_cast<f32>(width) / static_cast<f32>(height);
    projection = glm::perspective(glm::radians(FOV), aspect, 0.1f, Z_FAR);
}

void mouse_callback(GLFWwindow* window, f64 xpos, f64 ypos) {
    if (firstMouse)
    {
        lastX = xpos;
        lastY = ypos;
        firstMouse = false;
    }

    f64 xoffset = xpos - lastX;
    f64 yoffset = lastY - ypos;
    lastX = xpos;
    lastY = ypos;

    //if (xoffset != 0.0L || yoffset != 0.0L) uiPage->mouseHoverDisabled = false;

    xoffset *= mouseSensitivity;
    yoffset *= mouseSensitivity;

    yaw += xoffset;
    pitch += yoffset;

    if (pitch > 89.0L)  pitch = 89.0L;
    if (pitch < -89.0L) pitch = -89.0L;

    xpos /= windowWidth;
    ypos /= windowHeight;
    game.game_update_input(-1 ,-1, xpos, ypos);

    //if (gameState == GAME_STATE::DEBUG || gameState == GAME_STATE::PLAY) {
    //    vec3 front(cos(glm::radians(yaw)) * cos(glm::radians(pitch)), sin(glm::radians(pitch)), sin(glm::radians(yaw)) * cos(glm::radians(pitch)));
    //    cameraFront = glm::normalize(front);
    //    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    //}
    //else {
    //    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
    //}
}

void mouse_button_callback(GLFWwindow* window, i32 button, i32 action, i32 mods) {
  /*  if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS && uiPage->elementHovered != -1) {
        f64 xpos, ypos;
        glfwGetCursorPos(window, &xpos, &ypos);
        xpos /= windowWidth;
        ypos /= windowHeight;
        uiPage->uiElements[uiPage->elementHovered].action();
    }*/
}

void key_callback(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods) {
   game.game_update_input(action, key, -1, -1);
}

void load_textures() {
    load_texture("./res/circuit_board.png", false, false, false);
    load_texture("./res/panel_background.png", false, true, false);
    load_texture("./res/lines.png", true, true, true); //this is a stupid white texture btw.
    load_texture("./res/door.png", true, false, true);
    load_texture("./res/player-sheet.png", true, true, false);
    load_texture("./res/hdd_sprite_sheet_1024.png", true, false, false);
    load_texture("./res/diskette_unlock_sheet2.png", true, false, false);
    load_texture("./res/item-hub.png", true, false, true);
    load_texture("./res/boost-sheet.png", true, false, true);
    load_texture("./res/confetti-sheet.png", true, false, true);
    load_texture("./res/rfid_sheet_1024.png", true, false, false);
    load_texture("./res/+512.png", true, false, false);
    load_texture("./res/+128.png", true, false, false);
    load_texture("./res/+1024.png", true, false, false);
    load_texture("./res/2x.png", true, false, false);
    load_texture("./res/4x.png", true, false, false);
    load_texture("./res/8x.png", true, false, false);
    load_texture("./res/diskette_sheet_1024.png", true, false, false);
    load_texture("./res/box_randomizer.png", true, false, false);
    load_texture("./res/watt-sheet3.png", true, false, false);
}
